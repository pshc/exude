use std::fs::{self, File};
use std::io::{self, Write};
use std::path::{Path, PathBuf};
use std::str;

use digest::{Input, VariableOutput};
use futures::{Future, Stream, future};
use futures_cpupool::CpuPool;
use hyper::{self, Client, Uri};
use sha3::Shake128;
use sodiumoxide::crypto::sign::{self, PublicKey};
use tokio_core::reactor::{Core, Handle};
use tokio_io::AsyncRead;

use common::{self, OurFuture};
use errors::*;
use proto::{Digest, DriverInfo, digest, handshake};

/// Generated by `cd issuer; cargo run -- keygen`.
pub static PUBLIC_KEY: PublicKey = PublicKey(*include_bytes!("../../issuer/cred/public"));


/// Downloads the newest driver (if needed), returning its path.
pub fn fetch_driver<R: AsyncRead + 'static>(
    reader: R,
    ) -> OurFuture<(R, Box<DriverInfo>, PathBuf)> {

    box common::read_bincoded::<_, handshake::Welcome<Box<DriverInfo>>>(reader).and_then(
        move |(reader, welcome)| -> OurFuture<_> {

            match welcome {
                handshake::Welcome::Current => unimplemented!(),
                handshake::Welcome::Obsolete => {
                    box future::err("obsolete; please install a new client manually".into())
                }
                handshake::Welcome::Download(uri, info) => {
                    // verify that the signature is ok
                    let sig = sign::Signature(info.sig.0);
                    let verified = sign::verify_detached(&sig, &info.digest.0, &PUBLIC_KEY);
                    if !verified {
                        return box future::err("sig check failed".into());
                    }

                    let uri: Uri = try_box!(uri.parse().map_err(hyper::Error::Uri));
                    box download_in_bg(uri, info)
                        .map(|(info, path)| (reader, info, path))
                }
            }
        }
    )
}

pub fn download_in_bg(uri: Uri, info: Box<DriverInfo>) -> OurFuture<(Box<DriverInfo>, PathBuf)> {
    box CpuPool::new(1)
        .spawn_fn(
            move || -> Result<_> {
                let mut core = Core::new()?;
                let handle = core.handle();
                core.run(download(uri, info, &handle))
            }
        )
}

fn download(
    uri: Uri,
    info: Box<DriverInfo>,
    handle: &Handle,
    ) -> OurFuture<(Box<DriverInfo>, PathBuf)> {

    let client = Client::new(handle);
    box client
        .get(uri)
        .then(|res| res.chain_err(|| "requesting driver download"))
        .and_then(|resp| -> OurFuture<_> {
            // xxx put this in tmp folder first
            let mut path = repo_path().to_owned();
            let hex = info.digest.hex_bytes();
            path.push(unsafe { str::from_utf8_unchecked(&hex) });

            let file = try_box!(File::create(&path));
            let hasher = Shake128::default();

            // hash download while writing it to fs
            // idea: if we could extract the Bytes from Chunk::Shared,
            //       we could send chunks to yet another thread, for hashing
            box resp.body()
                .then(|res| res.chain_err(|| "reading driver download"))
                .fold((file, hasher), |(mut f, mut h), chunk| -> Result<_> {
                    f.write_all(&chunk)?;
                    h.process(&chunk);
                    Ok((f, h))
                })
                .and_then(move |(mut file, hasher)| -> Result<_> {
                    // verify that the binary hashes to the digest
                    let mut result = [0u8; digest::LEN];
                    hasher.variable_result(&mut result).expect("hashing");
                    if Digest(result) != info.digest {
                        if let Err(e) = fs::remove_file(path) {
                            println!("remove failed download: {}", e);
                        }
                        return Err("hash check failed".into());
                    }

                    file.flush().chain_err(|| "finalizing download")?;
                    Ok((info, path))
                })
        })
}

fn repo_path() -> &'static Path {
    use std::sync::{ONCE_INIT, Once};

    static MKDIR: Once = ONCE_INIT;
    static mut PATH: Option<PathBuf> = None;

    MKDIR.call_once(
        || {
            let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
            path.push("repo");

            match fs::create_dir(&path) {
                Ok(()) => (),
                Err(ref e) if e.kind() == io::ErrorKind::AlreadyExists => (),
                Err(e) => panic!("couldn't create {:?}: {}", path, e),
            }

            unsafe { PATH = Some(path) }
        }
    );

    unsafe { PATH.as_ref().expect("repo path") }
}

#[test]
fn test_repo_path() {
    let path = repo_path();
    assert!(path.ends_with("repo"));
    assert!(path.parent().expect("repo parent").exists());
}
